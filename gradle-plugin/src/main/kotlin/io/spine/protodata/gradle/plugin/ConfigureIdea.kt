/*
 * Copyright 2024, TeamDev. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Redistribution and use in source and/or binary forms, with or without
 * modification, must retain the above copyright notice and the following
 * disclaimer.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package io.spine.protodata.gradle.plugin

import com.google.protobuf.gradle.GenerateProtoTask
import io.spine.protodata.gradle.debug
import io.spine.string.Separator
import io.spine.tools.gradle.protobuf.generatedSourceProtoDir
import java.io.File
import java.nio.file.Path
import kotlin.io.path.Path
import java.nio.file.Paths
import org.gradle.api.Project
import org.gradle.api.logging.Logger
import org.gradle.api.tasks.TaskCollection
import org.gradle.kotlin.dsl.getByType
import org.gradle.plugins.ide.idea.model.IdeaModel
import org.gradle.plugins.ide.idea.model.IdeaModule

/**
 * Ensures that the sources generated by Protobuf Gradle plugin are
 * not included in the IDEA project.
 *
 * IDEA should only see the sources generated by ProtoData as
 * we define in [GenerateProtoTask.configureSourceSetDirs].
 */
internal fun Project.configureIdea() {
    val thisProject = this
    gradle.afterProject {
        if (it == thisProject) {
            pluginManager.withPlugin("idea") {
                val idea = extensions.getByType<IdeaModel>()
                idea.module.setupDirectories(thisProject)
            }
        }
    }
}

/**
 * Configures directory settings in this [IdeaModule] in the following way:
 *
 * 1. Marks directories under `build/generated/source/proto` as excluded.
 * 2. Filters these directories from being viewed as [sourceDirs][IdeaModule.sourceDirs].
 * 3. Marks directories under [Project.generatedDir] as those with generated sources.
 * 4. Marks `extracted-include-protos`, `extracted-protos`, and their children as excluded.
 */
private fun IdeaModule.setupDirectories(project: Project) {
    val protocOutput = project.file(project.generatedSourceProtoDir)
    val protocTargets = project.protocTargets()
    excludeWithNested(protocOutput.toPath(), protocTargets)
    sourceDirs = FilteringFileSet(sourceDirs, protocOutput, project.logger)
    testSources.filter { !it.residesIn(protocOutput) }
    generatedSourceDirs = project.generatedDir.resolve(protocTargets)
        .map { it.toFile() }
        .toSet()
    excludeExtractedDirs(project)
}

/**
 * Marks the directories `extracted-include-protos` and `extracted-protos` and their
 * subdirectories as excluded in this [IdeaModule].
 */
private fun IdeaModule.excludeExtractedDirs(project: Project) {
    val sourceSetDirs = project.generateProtoTasks().map { Path(it.sourceSet.name) }
    val extractedIncludeProtos = project.buildDir.resolve("extracted-include-protos").toPath()
    val extractedProtos = project.buildDir.resolve("extracted-protos").toPath()

    excludeWithNested(extractedIncludeProtos, sourceSetDirs)
    excludeWithNested(extractedProtos, sourceSetDirs)
}

/**
 * Excludes the given directory and its subdirectories from
 * being seen as ones with the source code.
 */
private fun IdeaModule.excludeWithNested(directory: Path, subdirs: Iterable<Path>) {
    excludeDirs.add(directory.toFile())
    directory.resolve(subdirs).forEach {
        excludeDirs.add(it.toFile())
    }
}

/**
 * Lists target directories for Protobuf code generation.
 *
 * The directory names are in the following format:
 *
 * `<source-set-name>/<builtIn-or-plugin-name>`
 */
internal fun Project.protocTargets(): List<Path> {
    val protobufTasks = generateProtoTasks()
    val codegenTargets = sequence {
        protobufTasks.forEach { task ->
            val sourceSet = task.sourceSet.name
            val builtins = task.builtins.map { builtin -> builtin.name }
            val plugins = task.plugins.map { plugin -> plugin.name }
            val combined = builtins + plugins
            combined.forEach { subdir ->
                yield(Paths.get(sourceSet, subdir))
            }
        }
    }
    return codegenTargets.toList()
}

private fun Project.generateProtoTasks(): TaskCollection<GenerateProtoTask> =
    tasks.withType(GenerateProtoTask::class.java)

/**
 * A file set which filters out files or directories belonging to [excludedDir].
 *
 * The set filters out incoming [delegate] set on initialization.
 * It also overrides [add] and [addAll] preventing subsequent adding of unwanted elements.
 *
 * We set such "forceful" implementation of filtering when configuring source directories of
 * an `IdeaModule`. This is to make sure that the filtering works disregarding the order of
 * invocation of [Project.afterEvaluate] or [org.gradle.api.invocation.Gradle.afterProject] blocks.
 *
 * @see IdeaModule.setupDirectories
 */
private class FilteringFileSet(
    private val delegate: MutableSet<File>,
    private val excludedDir: File,
    private val logger: Logger
): MutableSet<File> by delegate {

    init {
        delegate.removeIf {
            val excluded = it.residesIn(excludedDir)
            if (excluded) {
                logger.debug {
                    "Excluding `$it` from IDEA module source directories."
                }
            }
            excluded
        }
    }

    override fun add(element: File): Boolean {
        if (!element.residesIn(excludedDir)) {
            logger.debug { "Adding `$element` as IDEA module source directory." }
            return delegate.add(element)
        }
        logger.debug { "`$element` NOT added as IDEA module source directory." }
        return false
    }

    override fun addAll(elements: Collection<File>): Boolean {
        val filtered = elements.excluding(excludedDir)
        val nl = Separator.nl()
        if (filtered.isNotEmpty()) {
            logger.debug {
                "Adding IDEA module source directories:$nl" +
                        filtered.joinToString(nl) { "  ${it.name}" }
            }
        }
        if (filtered.size != elements.size) {
            val excluded = elements.toSet() - filtered
            logger.debug {
                "Excluded directories:$nl" +
                        excluded.joinToString(nl) { "  ${it.name}" }
            }
        }
        return delegate.addAll(filtered)
    }
}
