/*
 * Copyright 2021, TeamDev. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Redistribution and use in source and/or binary forms, with or without
 * modification, must retain the above copyright notice and the following
 * disclaimer.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package io.spine.protodata.plugin

import io.spine.base.EntityState
import io.spine.protobuf.ValidatingBuilder
import io.spine.server.DefaultRepository
import io.spine.server.entity.model.EntityClass
import io.spine.server.projection.Projection
import io.spine.server.projection.ProjectionRepository
import io.spine.server.projection.model.ProjectionClass
import io.spine.server.route.EventRoute
import io.spine.server.route.EventRouting
import kotlin.reflect.KClass

/**
 * A view on the Protobuf sources.
 *
 * A view is constructed from the events obtained from the Protobuf Compiler, or generated by
 * a [Policy].
 *
 * Listen to the events using single parameter methods annotated with
 * [@Subscribe][io.spine.core.Subscribe]. In these methods, change the state of the view via
 * the `builder()` method.
 *
 * We recommend to use `internal` access for the subscriber methods in Kotlin and package-private â€”
 * in Java. The methods are not `private`, as they are invoked by the framework, and no `public`,
 * as they must not be called directly.
 *
 * Events from the Protobuf compiler should be marked as [@External][io.spine.core.External], while
 * events from policies should not.
 *
 * Example:
 * ```
 * class MyView : View<FieldName, Field, Field.Builder> {
 *
 *     @Subscribe
 *     internal fun on(event: SomethingHappened) {
 *         // Change the view via `builder()`.
 *     }
 *
 *     @Subscribe
 *     internal fun on(@External event: FieldOptionDiscovered) {
 *         // Change the view via `builder()`.
 *     }
 * }
 * ```
 *
 * Views have repositories which are responsible for storing states and for delivering correct
 * events to the correct views. See [ViewRepository] for more.
 *
 * @param I the type of the ID of the view; can be a Protobuf message, a String, an int, or a long
 * @param M the type of the view's state; must be a Protobuf message
 * @param B the type of the view's state builder; must match `<M>`
 */
public open class View<I, M : EntityState, B : ValidatingBuilder<M>> : Projection<I, M, B>()

/**
 * A repository responsible for a certain type of [View]s.
 *
 * By default, when an event is headed towards a [View], we try to match the first field of
 * the event with the ID of the view. This is called routing. If the types match, the event is
 * routed to the view with the matching ID. Otherwise, an error occurs.
 *
 * To change the rules of event routing, override the [ViewRepository.setupEventRouting] method.
 *
 * If no customization is required from a `ViewRepository`, users should prefer
 * [ViewRepository.default] to creating custom repository types.
 */
public open class ViewRepository<I, V : View<I, S, *>, S : EntityState>
    : ProjectionRepository<I, V, S>() {

    public companion object {

        @JvmStatic
        public fun <I, V : View<I, S, *>, S : EntityState> default(cls: Class<V>)
                : ViewRepository<I, V, S> =
            DefaultViewRepository(cls)


        public fun <I, V : View<I, S, *>, S : EntityState> default(cls: KClass<V>)
                : ViewRepository<I, V, S> =
            default(cls.java)
    }

    override fun setupEventRouting(routing: EventRouting<I>) {
        super.setupEventRouting(routing)
        routing.replaceDefault(EventRoute.byFirstMessageField(idClass()))
    }
}

/**
 * A default [ViewRepository].
 *
 * A [ViewRepository] can be customized in case event routing must be adjusted. Otherwise, users
 * should use `DefaultViewRepository` by calling [ViewRepository.default].
 */
internal class DefaultViewRepository<I, V : View<I, S, *>, S : EntityState>(
    private val cls: Class<V>
) : ViewRepository<I, V, S>(), DefaultRepository {

    override fun entityModelClass(): EntityClass<V> {
        return ProjectionClass.asProjectionClass(cls)
    }

    override fun logName(): String {
        return "${ViewRepository::class.simpleName}.default()"
    }
}
